# Лабораторная работа №3. Транслятор и модель процессора

* P3230. Шевченко Дарья Павловна
* ```forth | stack | harv | hw | tick | struct | stream | port | pstr | prob1```
* Базовый вариант

## Язык программирования

```text

<процедура> →   ": " <название процедуры> <программа> " ;"

<программа> →   <пусто> | <слово> | <программа> " " <программа> | <условный оператор> |
                <оператор цикла do loop> | <оператор цикла begin until> <объявление переменной>
                
<объявление переменной> → "variable " <переменная> ["allot " <целочисленный литерал>] 

<условный оператор> → if <программа> [else <программаа>] then  

<оператор цикла do loop> → do <программа> loop  

<оператор цикла begin until> → begin <программа> until  

<слово> →   <целочисленный литерал> | <математический оператор> | <отображение строки> | <название процедуры> |
            "mod" | "drop" | "swap" | "over" | "dup" | "read" | "omit" | <переменная> | "@" | "!" | "ei" | "di"

<математический оператор> → "+" | "-" | "*" | "/" | "=" | "<" | ">" 

<отображение строки> → "." <строковый литерал>

```

Код выполняется последовательно за исключением процедур.
Вызов процедуры осуществляется при указании в программе её названия. Комментарии не предусмотрены.


Ниже описаны основные стековые операции в виде stack_before >> stack_after

* ```+``` - (n1 n2 >> n3)
* ```-``` - (n1 n2 >> n3)
* ```*``` - (n1 n2 >> n3)
* ```/``` - (n1 n2 >> n3)
* ```=``` - (n1 n2 >> n3) n3 = 1 if n1 == n2 n3 = 0 if n1 != n2
* ```>``` - (n1 n2 >> n3) n3 = 1 if n1 > n2 n3 = 0 if n1 <= n2
* ```<``` - (n1 n2 >> n3) n3 = 1 if n1 < n2 n3 = 0 if n1 >= n2
* ```mod``` - (n1 n2 >> n3)
* ```drop``` - (n1 n2 >> n1)
* ```swap``` - (n1 n2 >> n2 n1)
* ```over``` - (n1 n2 >> n1 n2 n1)
* ```dup``` - (n1 >> n1 n1) 
* ```key``` - (n1 >> n2) - ввод c порта n1
* ```omit``` - (n1 n2 >> ) - вывести ASCII символ с кодом n1 в IO порт n2
* ```read``` - (n1 >> n2) - прочитать значение с порта n1 и положить на стек
* ```!``` - (n1 n2 >> ) - записать значение n1 в ячейку памяти n2
* ```@``` - (n1 >> n2) - прочитать значение из ячейки памяти n1 и положить его на стек
* ```ei``` - ( >> ) - включить прерывания
* ```di``` - ( >> ) - отключить прерывания

Код подразумевает использование условных переходов:
* ```if```
* ```do loop```
* ```begin until```

Условный оператор ```if``` выполняется в зависимости от истинности значения на вершине стека.
Истинное значение - любое число, кроме нуля. Ложное значение - 0.

Оператор цикла ```do loop``` выполняет ```N``` итераций в зависимости от двух значений на вершине стека (n1 n2);
```N = n1 - n2```. Внутри конструкции ```do loop``` возможно использовать
переменную ```i```, ```i = n2 + <номер итерации>```.
Аналогично конструкции ```for (i = n2; i < n1; i++) {}``` 

Оператор цикла ```begin until``` выполняет итерации до момента, когда на вершине стека
по достижению конструкции until не будет лежать истинное значение (отличное от нуля).

Оператор объявления переменной ```variable``` создаёт переменную и сопоставляет ей
определенную ячейку памяти, взаимодействовать с которой возможно при помощи ```!``` и ```@```.
В случае добавления ключевого слова ```allot``` выделяется непрерывный участок памяти с фиксированным
в программе размером.

Комментарии не предусмотрены.

Используемые литералы:

* строковые литералы - имеют вид " <строка>", используются для экранизации текста после оператора ```.```
* целочисленные литералы - являются полноценным словом в программе и необходимы для того, чтобы положить конкретное
  значение на вершину стека, диапазон значений - $[-2^{31}, 2^{31} - 1]$

## Организация памяти

* Память данных и команд раздельна
* Размер машинного слова данных 32 бита
* Размер машинного слова команд -- 40 бит, первые 8 бит -- тип команды (размер условен, кодирование в виде json)
* Программисту в явном виде доступен исключительно стек данных и память, зарезервированная
  под переменные
* Память данных и команд выделяется статически при запуске модели (в Control Unit)
* Доступен один вид прерываний - его обработчик лежит по адресу 01 в памяти команд
* Процедуры хранятся в памяти последовательно, после прерываний и вызов может быть выполнен из любой
  части программы.
* Машинная команда может использоваться как с аргументами (адрес/значение), так и без них.
* Ввиду специфики варианта, числовые и строковые литералы записываются в память данных в
  момент исполнения программы, а не при запуске модели с помощью команд с Immediate Value.
  Формирование команд для записи строковых литералов -- на этапе трансляции
* Все переменные хранятся статически в памяти данных
* Используется стек данных и стек возврата, они являются отдельным физическим устройством
  по отношению к памяти данных и команд

Память команд
- адресное пространство от 00 до 15000, с 01 ячейки размещаются interrupt handler, после идут обычные команды
```text

+-----------------------------+
| 00       jmp N              |
| 01       interrupt handle   |
|      ...                    |
| N - 1    interrupt handle   |
+-----------------------------+
| N        program            |
| N + 1    program            |
|      ...                    |
| 15000    program            |
+-----------------------------+
```

Память данных
- идет снизу вверх, представляет собой адресное пространство от 00 до 15000, от 00 до 511 хранятся строковые литералы, остальное выделено для переменных
```text
+-----------------------------+
| 00       string literals    |  |
| 01       string literals    |  |
|      ...                    |  v
| 511      strings literal    |  
+-----------------------------+
| 512      variables          |  |
| 513      variables          |  |
|      ...                    |  v
| 15000    variables          |  
+-----------------------------+

```

Команда в памяти команд (в варианте используется json-кодирование):

```text
+-----------------------------------------------------------+
| Код команды (0:7) | Адрес / Immediate Value (8:39)        |
+-----------------------------------------------------------+
```
## Система команд

### Цикл исполнения команды

1) Выборка инструкции (осуществляется в один такт с исполнением инструкции без сохранения информации в промежуточные регистры)
2) Проверка на прерывание (если прерывание, сохранение PC в Return Stack, переход к обработчику прерывания)
3) Исполнение команды (количество тактов необходимых для исполнения указано в таблице ниже)
### Набор инструкций

Большинство инструкций языка в явном виде соответствуют машинным командам, в таблице ниже
приведены все элементы системы команд ([isa.py](isa.py)). Те машинные команды, которые без комментария --
соответствуют слову из языка программирования.

| Инструкция  | Кол-во тактов | Комментарий                                                            |
|:------------|:--------------|:-----------------------------------------------------------------------|
| mul         | 2             |                                                                        |
| div         | 2             |                                                                        |
| sub         | 2             |                                                                        |
| add         | 2             |                                                                        |
| mod         | 2             |                                                                        |
| eq          | 2             |                                                                        |
| gr          | 2             |                                                                        |
| ls          | 2             |                                                                        |
| drop        | 2             |                                                                        |
| swap        | 3             |                                                                        |
| over        | 4             |                                                                        |
| dup         | 2             |                                                                        |
| ei          | 1             | разрешить прерывания                                                   |
| di          | 1             | запретить прерывания                                                   |
| omit        | 4             |                                                                        |
| read        | 2             |                                                                        |
| store       | 4             | память данных из стека                                                 |
| load        | 2             | в стек из памяти данных                                                |
| push <imm>  | 3             | записать в стек непосредственное значение                              |
| pop         | 4             | перенести значение со стека данных в стек возврата                     |
| rpop        | 1             | перенести значение из стека возврата в стек данных                     |
| jmp <addr>  | 1             | перейти по адресу                                                      |
| zjmp <addr> | 1             | перейти по адресу, если на вершине стека 0 (убирает значение со стека) |
| call <addr> | 1             | вызов процедуры                                                        |
| ret         | 1             | выход из процедуры или прерывания                                      |
| halt        |               | завершение программы                                                   |

Количество тактов обусловлено спецификой устройства процессора, подробнее -- в разделе "Модель процессора".

### Кодирование инструкций

Машинный код сериализуется в список JSON.
Один элемент списка, одна инструкция.
Инструкции кодируются в формат JSON и имеют вид:
```json
 {
  "index": 1,
  "command": "push",
  "arg": 0
}
```

В данной конструкции аргумент опционален и может быть упущен в зависимости от типа команды.

## Транслятор

Интерфейс командной строки `translator.py <input_file> <target_file>`
